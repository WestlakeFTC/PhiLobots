#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Hubs,  S3, HTMotor,  HTServo,  HTServo,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     HTMUX,          sensorI2CCustomFastSkipStates9V)
#pragma config(Motor,  mtr_S1_C1_1,     BackL,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     FrontL,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     MidR,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     MidL,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     BackR,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     FrontR,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S3_C1_1,     FanR,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S3_C1_2,     FanL,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    flapper1,             tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_2,    flapper2,             tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
#pragma config(Servo,  srvo_S3_C2_1,    trailerR,             tServoStandard)
#pragma config(Servo,  srvo_S3_C2_2,    trailerL,             tServoStandard)
#pragma config(Servo,  srvo_S3_C2_3,    lift,                 tServoStandard)
#pragma config(Servo,  srvo_S3_C2_4,    servo10,              tServoNone)
#pragma config(Servo,  srvo_S3_C2_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S3_C2_6,    servo12,              tServoNone)
#pragma config(Servo,  srvo_S3_C3_1,    flapper3,             tServoContinuousRotation)
#pragma config(Servo,  srvo_S3_C3_2,    spout,                tServoStandard)
#pragma config(Servo,  srvo_S3_C3_3,    faucet,               tServoStandard)
#pragma config(Servo,  srvo_S3_C3_4,    servo16,              tServoNone)
#pragma config(Servo,  srvo_S3_C3_5,    servo17,              tServoNone)
#pragma config(Servo,  srvo_S3_C3_6,    servo18,              tServoNone)
#pragma config(Servo,  srvo_S3_C4_1,    servo19,              tServoNone)
#pragma config(Servo,  srvo_S3_C4_2,    servo20,              tServoNone)
#pragma config(Servo,  srvo_S3_C4_3,    servo21,              tServoNone)
#pragma config(Servo,  srvo_S3_C4_4,    servo22,              tServoNone)
#pragma config(Servo,  srvo_S3_C4_5,    servo23,              tServoNone)
#pragma config(Servo,  srvo_S3_C4_6,    servo24,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define DEBUG

// number of encoder ticks per revolution of the motor
#define TICKS_PER_REVOLUTION (280 * 4)

// number of revolutions of the wheel per revolution of the motor
#define GEAR_RATIO						2.6

#define WHEEL_CIRCUMFERENCE		(4 * 3.14159)

// number of encoder ticks per inch of travel
#define TICKS_PER_INCH (TICKS_PER_REVOLUTION / WHEEL_CIRCUMFERENCE / GEAR_RATIO)

// distance the middle wheel travels during one full pivot
#define PIVOT_CIRCUMFERENCE (16.5 * 3.14159)

// number of encoder ticks per degree of pivot
#define TICKS_PER_DEGREE (TICKS_PER_INCH * PIVOT_CIRCUMFERENCE / 360)

#define INCHES_PER_DEGREE (TICKS_PER_DEGREE / TICKS_PER_INCH)

// tunable parameters
#define RAMP_UP_STEPS 10

	// number of steps to go from 0 to full power
#define LINEAR_SCALING (0.05) // ratio of power difference to encoder difference
#define INTEGRAL_SCALING (0.001)
#define STRAIGHT_SLOWDOWN_INCHES 6			// number of inches before the end at which to start slowing down
#define PIVOT_SLOWDOWN_INCHES 6			// number of inches before the end at which to start slowing down
#define MIN_POWER 20
#define TIME_STEP 20

void setLeftPower(int power) {
	motor[FrontL] = motor[MidL] = motor[BackL] = power;
}

void setRightPower(int power) {
	motor[FrontR] = motor[MidR] = motor[BackR] = power;
}

/*
 * Move the motors for the given number of inches at the given power.
 * The robot will pivot or move straight depending on the left and right
 * directions.  leftDir and rightDir should only be 1 or -1 since they are
 * used to scale the absolute power.  The wheel rotations are aligned by
 * proportionally varying the power with the encoder difference.
 */
void moveTank(int leftDir, int rightDir, float inches, int power, float slowdown) {
	float scaledPower, delta, leftPower, rightPower;

	int timeStart = nSysTime;

	float displacement = 0; // how far from the center we have deviated
	int count =0;
	// reset encoders
	nMotorEncoder[FrontL] = 0;
	nMotorEncoder[FrontR] = 0;

	// calculate encoder target
	float target = inches * TICKS_PER_INCH;

#ifdef DEBUG
	writeDebugStreamLine("target is %d inches, %d ticks", inches, target);

//	sleep(100);
#endif //DEBUG

	// slowly ramp up the motors
	int leftCount=0;
	int rightCount=0;

	for (int i = 0 ; (i < RAMP_UP_STEPS) && (leftCount + rightCount < target); i++)
	{
		leftCount = abs(nMotorEncoder[FrontL]);
		rightCount = abs(nMotorEncoder[FrontR]);
		displacement += (rightCount - leftCount);
		float currentPower = power / RAMP_UP_STEPS * i;
		delta = (rightCount-leftCount) * LINEAR_SCALING + displacement * INTEGRAL_SCALING;
		leftPower=currentPower+delta;
		rightPower=currentPower-delta;
		setLeftPower(leftDir * leftPower);
		setRightPower(rightDir * rightPower);
		sleep(TIME_STEP);
	}

	/*
	 * Loop until both motors reach target, slowing down as they get closer
	 * to the target.
	 */
	bool done = false;
	while (!done) {
		leftCount = abs(nMotorEncoder[FrontL]);
		rightCount = abs(nMotorEncoder[FrontR]);
		displacement += (rightCount - leftCount);

		const float averageCount = (rightCount + leftCount) * 0.5;
		const float slowDownDistance = (slowdown * TICKS_PER_INCH);

		scaledPower = power;
		if(averageCount > target - slowDownDistance)
		{
				float ratio = (target - averageCount) / slowDownDistance;
				if (ratio<0.5)
				{
					ratio=0.5;
				}
				scaledPower=scaledPower*ratio;
		}
		// keep scaled power above MIN_POWER so robot always moves
		if (scaledPower < MIN_POWER) scaledPower = MIN_POWER;

		delta = (rightCount-leftCount) * LINEAR_SCALING + displacement * INTEGRAL_SCALING;
		leftPower=scaledPower+delta;
		rightPower=scaledPower-delta;
	//	if (leftPower < MIN_POWER) leftPower = MIN_POWER;
	//	if (rightPower < MIN_POWER) rightPower = MIN_POWER;
		done = true;
		if (leftCount > target) {
			setLeftPower(0);
		} else {
			setLeftPower(leftDir *leftPower);
			done = false;
		}

		if (rightCount > target) {
			setRightPower(0);
		} else {
			setRightPower(rightDir *rightPower);
			done = false;
		}

#ifdef DEBUG
		writeDebugStreamLine("time= %d\t\tleft= %d\t\tright=%d\t\tdelta=%d\t\tlp=%f\t\trp=%f\t\tdisp=%f",
			nSysTime - timeStart, leftCount, rightCount,rightCount-leftCount, leftPower, rightPower, displacement);
#endif //DEBUG
 		sleep(TIME_STEP);
	}
}


void moveForward(float inches, int power) {
	moveTank(1, -1, inches, power, STRAIGHT_SLOWDOWN_INCHES);
}

void moveBackward(float inches, int power) {
	moveTank(-1, 1, inches, power, STRAIGHT_SLOWDOWN_INCHES);
}

void pivotLeft(float degrees, int power) {
	moveTank(-1, -1, degrees * INCHES_PER_DEGREE, power, PIVOT_SLOWDOWN_INCHES);
}

void pivotRight(float degrees, int power) {
	moveTank(1, 1, degrees * INCHES_PER_DEGREE, power, PIVOT_SLOWDOWN_INCHES);
}

void moveLeft(int dir, float inches, int power) {
	// reset encoders
	nMotorEncoder[FrontL] = 0;

	// calculate encoder target
	float target = inches * TICKS_PER_INCH;

#ifdef DEBUG
	writeDebugStreamLine("target is %d inches, %d ticks", inches, target);

//	sleep(100);
#endif //DEBUG

	setLeftPower(dir * power);
	int leftCount= abs(nMotorEncoder[FrontL]);
	while (leftCount<target){
		leftCount= abs(nMotorEncoder[FrontL]);
	}
	setLeftPower(0);
}


void moveRight(int dir, float inches, int power) {
	// reset encoders
	nMotorEncoder[FrontR] = 0;

	// calculate encoder target
	float target = inches * TICKS_PER_INCH;

#ifdef DEBUG
	writeDebugStreamLine("target is %d inches, %d ticks", inches, target);

//	sleep(100);
#endif //DEBUG

	setRightPower(dir * power);
	int rightCount= abs(nMotorEncoder[FrontR]);
	while (rightCount<target){
		rightCount= abs(nMotorEncoder[FrontR]);
	}
	setRightPower(0);
}
void wiggle()
{
	moveLeft(-1,2,30);
	moveRight(1,4,30);
	moveLeft(-1,4,30);
	moveRight(1,4,30);
	moveLeft(-1,2,30);
	setLeftPower(-30);
	setRightPower(30);
	sleep(300);
	setLeftPower(0);
	setRightPower(0);
//	moveBackward(5,30);
}
#define LIFT_DOWN 198
#define LIFT_60CM 165
#define LIFT_90CM 100
#define LIFT_120CM 35

void setLiftDown(){
	servo[lift]=LIFT_DOWN;
}

void setLift60cm(){
	servo[lift]=LIFT_60CM;
}

void setLift90cm(){
	servo[lift]=LIFT_90CM;
}

void setLift120cm(){
	servo[lift]=LIFT_120CM;
}

#define GRABBER_UP      100
#define GRABBER_DOWN    20

void goalGrabberUp() {
		servo[trailerR] = 200;
		servo[trailerL] = 75;
}

void goalGrabberDown() {
		servo[trailerR] = 75;
		servo[trailerL] = 150;
}

#define PIN_CLOSED 150
#define PIN_OPEN 50
void pinOpen(){
	servo[spout]=PIN_OPEN;
	}
void pinClosed(){
	servo[spout]=PIN_CLOSED;
}

//flapper servo positions
#define FLAPPER_FORWARD     255
#define FLAPPER_STOP        127
#define FLAPPER_REV         0
int flapper_state = FLAPPER_STOP;

void flapperForward()
{
	flapper_state = FLAPPER_FORWARD;
	servo[flapper1] =FLAPPER_FORWARD;
	servo[flapper2] = FLAPPER_FORWARD;
	servo[flapper3] = FLAPPER_FORWARD;
}
void flapperStop()
{
	flapper_state = FLAPPER_STOP;
	servo[flapper1] =FLAPPER_STOP;
	servo[flapper2] = FLAPPER_STOP;
	servo[flapper3] = FLAPPER_STOP;
}
void flapperReverse()
{
	flapper_state = FLAPPER_REV;
	servo[flapper1] =FLAPPER_REV;
	servo[flapper2] = FLAPPER_REV;
	servo[flapper3] = FLAPPER_REV;
}

#define FAUCET_INITIAL	0
#define FAUCET_DEPLOYED	160

void faucetInitial() {
	servo[faucet] = FAUCET_INITIAL;
}

void faucetDeployed() {
	servo[faucet] = FAUCET_DEPLOYED;
}

task main()
{
//	moveForward(72,40);
//	while(true) {}

	setLiftDown();
	pinClosed();
	sleep(300);
	faucetDeployed();
//	flapperStop();

	goalGrabberUp();
	moveBackward(48,25);
	setLift60cm();
	sleep(800);
	moveBackward(25,25);
	sleep(100);
	wiggle();


	// grab 60 cm goal
	goalGrabberDown();
	sleep(200);
	pinOpen();
	setLift90cm();
//	moveForward(5,30);
	pivotLeft(125,40);
	moveBackward(10,35);

	//release 60cm goal
	goalGrabberUp();
	moveForward(10,35);
	pivotRight(125,40);
	moveBackward(5,30);
	wiggle();

	// grab 90 cm goal
	goalGrabberDown();
//	pivotRight(15,50);
	moveLeft(1, 6, 35);
	moveForward(12,35);
	sleep(500);
	moveForward(72,35);
	while(true){
		}

}
