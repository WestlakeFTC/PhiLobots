#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S2,     HTSPB,          sensorI2CCustomFastSkipStates9V)
#pragma config(Sensor, S4,     HTMUX,          sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     FrontL,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     BackL,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     BackR,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     FrontR,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     MidR,          tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     MidL,          tmotorTetrix, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "SigmaDefs.h"
#include "WestCoaster.h"
#include "CenterGoalUs.h"
#include "JoystickDriver.c"
#include "hitechnic-gyro-task.h"

WestCoaster g_wcDrive;

#define DEBUG

// number of encoder ticks per revolution of the motor
#define TICKS_PER_REVOLUTION (280 * 4)

// number of revolutions of the wheel per revolution of the motor
#define GEAR_RATIO						1

#define WHEEL_CIRCUMFERENCE		(4 * 3.14159)

// number of encoder ticks per inch of travel
#define TICKS_PER_INCH (TICKS_PER_REVOLUTION / WHEEL_CIRCUMFERENCE / GEAR_RATIO)

// distance the middle wheel travels during one full pivot
#define PIVOT_CIRCUMFERENCE (16.5 * 3.14159)

// number of encoder ticks per degree of pivot
#define TICKS_PER_DEGREE (TICKS_PER_INCH * PIVOT_CIRCUMFERENCE / 360)

#define INCHES_PER_DEGREE (TICKS_PER_DEGREE / TICKS_PER_INCH)

// tunable parameters
#define RAMP_UP_STEPS 10

	// number of steps to go from 0 to full power
#define LINEAR_SCALING (0.05) // ratio of power difference to encoder difference
#define INTEGRAL_SCALING (0.001)
#define STRAIGHT_SLOWDOWN_INCHES 6			// number of inches before the end at which to start slowing down
#define PIVOT_SLOWDOWN_INCHES 6			// number of inches before the end at which to start slowing down
#define MIN_POWER 20
#define TIME_STEP 20

void setLeftPower(int power) {
	writeDebugStreamLine("setting left power: %d", power);
	motor[FrontL] = power;
	motor[MidL] = power;
	motor[BackL] = power;
}

void setRightPower(int power) {
	motor[FrontR] = motor[MidR] = motor[BackR] = power;
}

/*
 * Move the motors for the given number of inches at the given power.
 * The robot will pivot or move straight depending on the left and right
 * directions.  leftDir and rightDir should only be 1 or -1 since they are
 * used to scale the absolute power.  The wheel rotations are aligned by
 * proportionally varying the power with the encoder difference.
 */
void moveTank(int leftDir, int rightDir, float inches, int power, float slowdown) {
	float scaledPower, delta, leftPower, rightPower;

	int timeStart = nSysTime;

	float displacement = 0; // how far from the center we have deviated
	int count =0;
	// reset encoders
	nMotorEncoder[BackL] = 0;
	nMotorEncoder[BackR] = 0;

	// calculate encoder target
	float target = inches * TICKS_PER_INCH;

#ifdef DEBUG
	writeDebugStreamLine("target is %d inches, %d ticks", inches, target);

//	sleep(100);
#endif //DEBUG

	// slowly ramp up the motors
	int leftCount=0;
	int rightCount=0;

	for (int i = 0 ; (i < RAMP_UP_STEPS) && (leftCount + rightCount < target); i++)
	{
		leftCount = abs(nMotorEncoder[BackL]);
		rightCount = abs(nMotorEncoder[BackR]);
		displacement += (rightCount - leftCount);
		float currentPower = power / RAMP_UP_STEPS * i;
		delta = (rightCount-leftCount) * LINEAR_SCALING + displacement * INTEGRAL_SCALING;
		leftPower=currentPower+delta;
		rightPower=currentPower-delta;
		setLeftPower(leftDir * leftPower);
		setRightPower(rightDir * rightPower);
		sleep(TIME_STEP);
	}

	/*
	 * Loop until both motors reach target, slowing down as they get closer
	 * to the target.
	 */
	bool done = false;
	while (!done) {
		leftCount = abs(nMotorEncoder[BackL]);
		rightCount = abs(nMotorEncoder[BackR]);
		displacement += (rightCount - leftCount);

		const float averageCount = (rightCount + leftCount) * 0.5;
		const float slowDownDistance = (slowdown * TICKS_PER_INCH);

		scaledPower = power;
		if(averageCount > target - slowDownDistance)
		{
				float ratio = (target - averageCount) / slowDownDistance;
				if (ratio<0.5)
				{
					ratio=0.5;
				}
				scaledPower=scaledPower*ratio;
		}
		// keep scaled power above MIN_POWER so robot always moves
		if (scaledPower < MIN_POWER) scaledPower = MIN_POWER;

		delta = (rightCount-leftCount) * LINEAR_SCALING + displacement * INTEGRAL_SCALING;
		leftPower=scaledPower+delta;
		rightPower=scaledPower-delta;
	//	if (leftPower < MIN_POWER) leftPower = MIN_POWER;
	//	if (rightPower < MIN_POWER) rightPower = MIN_POWER;
		done = true;
		if (leftCount > target) {
			setLeftPower(0);
		} else {
			setLeftPower(leftDir *leftPower);
			done = false;
		}

		if (rightCount > target) {
			setRightPower(0);
		} else {
			setRightPower(rightDir *rightPower);
			done = false;
		}

#ifdef DEBUG
		writeDebugStreamLine("time= %d\t\tleft= %d\t\tright=%d\t\tdelta=%d\t\tlp=%f\t\trp=%f\t\tdisp=%f",
			nSysTime - timeStart, leftCount, rightCount,rightCount-leftCount, leftPower, rightPower, displacement);
#endif //DEBUG
 		sleep(TIME_STEP);
	}
}


void moveForward(float inches, int power) {
	moveTank(1, -1, inches, power, STRAIGHT_SLOWDOWN_INCHES);
}

void moveBackward(float inches, int power) {
	moveTank(-1, 1, inches, power, STRAIGHT_SLOWDOWN_INCHES);
}

void pivotLeft(float degrees, int power) {
	moveTank(-1, -1, degrees * INCHES_PER_DEGREE, power, PIVOT_SLOWDOWN_INCHES);
}

void pivotRight(float degrees, int power) {
	moveTank(1, 1, degrees * INCHES_PER_DEGREE, power, PIVOT_SLOWDOWN_INCHES);
}

void moveLeft(int dir, float inches, int power) {
	// reset encoders
	nMotorEncoder[FrontL] = 0;

	// calculate encoder target
	float target = inches * TICKS_PER_INCH;

#ifdef DEBUG
	writeDebugStreamLine("target is %d inches, %d ticks", inches, target);

//	sleep(100);
#endif //DEBUG

	setLeftPower(dir * power);
	int leftCount= abs(nMotorEncoder[FrontL]);
	while (leftCount<target){
		writeDebugStreamLine("%d ticks", leftCount);

		leftCount= abs(nMotorEncoder[FrontL]);

	}
	setLeftPower(0);
}


void moveRight(int dir, float inches, int power) {
	// reset encoders
	nMotorEncoder[FrontR] = 0;

	// calculate encoder target
	float target = inches * TICKS_PER_INCH;

#ifdef DEBUG
	writeDebugStreamLine("target is %d inches, %d ticks", inches, target);

//	sleep(100);
#endif //DEBUG

	setRightPower(dir * power);
	int rightCount= abs(nMotorEncoder[FrontR]);
	while (rightCount<target){
		rightCount= abs(nMotorEncoder[FrontR]);
	}
	setRightPower(0);
}
void wiggle()
{
	moveLeft(-1,2,30);
	moveRight(1,4,30);
	moveLeft(-1,4,30);
	moveRight(1,4,30);
	moveLeft(-1,2,30);
	setLeftPower(-30);
	setRightPower(30);
	sleep(300);
	setLeftPower(0);
	setRightPower(0);
//	moveBackward(5,30);
}
void wiggleMove()
{
/*	WestCoaster_controlledEncoderObservedTurn(g_wcDrive,-15,35);
	WestCoaster_controlledStraightMove(g_wcDrive, -7,20);
	WestCoaster_controlledEncoderObservedTurn(g_wcDrive,30,35);
	WestCoaster_controlledStraightMove(g_wcDrive, -7,20);
	WestCoaster_controlledEncoderObservedTurn(g_wcDrive,-15,35);
	WestCoaster_controlledStraightMove(g_wcDrive, -7,20);

*/
	WestCoaster_turnWithMPU(g_wcDrive,-5,30);
	WestCoaster_controlledStraightMove(g_wcDrive, -7,25);
	WestCoaster_turnWithMPU(g_wcDrive,10,30);
	WestCoaster_controlledStraightMove(g_wcDrive, -7,25);
	WestCoaster_turnWithMPU(g_wcDrive,-5,30);
	WestCoaster_controlledStraightMove(g_wcDrive, -7,20);
}

void grabGoal()
{

	//you know what, we could re-use the center goal method
	// that is so cool!
   //moveForward(150,40);
  WestCoaster_controlledStraightMove(g_wcDrive,-50,40);
	//alignToGoal(g_wcDrive, CENTER_GOAL_SONAR, 15, 30);
	//wiggleMove();
	sleep(5000);

}

void initializeRobot()
{
	WestCoaster_init(g_wcDrive,FrontL, FrontR, MidL, MidR, BackL, BackR, BackL, BackR);
	WestCoaster_initMPUPID(S2);
	/*startTask(gyro_loop);
	while(gyro_loop_state!=GYRO_READING)
	{
		sleep(20);
	}*/
	//set to true during competition to keep the grabber engaged
	bSystemLeaveServosEnabledOnProgramStop=false;

}
#define ALIGN_FAUCET_TO_CENTER 50 //milliseconds to align faucet
#define OFF_RAMP_DIST 58 //platform and ramp measure 58 inches long
#define GOAL_CENTER_TO_EDGE 11.6/2
#define FAUCET_EXTEND_BACK_CENTER GOAL_CENTER_TO_EDGE+0.5 //measure from the center of the drop to the edge of robot

task main(){
	initializeRobot();
	//  waitForStart();
	/* sleep(1000);
	servo[foldRoller] = ROLLER_FOLDER_DOWN;
	sleep(1000);
	servo[foldRoller] = ROLLER_FOLDER_UP;
	sleep(1000);
	*/

	//===============
	// TESTS
	//
//wiggle();

	/**
	*            ***Turn and move with MPU with speed ramp up***
	**
	WestCoaster_turnWithMPU(g_wcDrive, -90,30);
	sleep(2000);
	WestCoaster_turnWithMPU(g_wcDrive, 90,30);
	sleep(2000);
	WestCoaster_turnWithMPU(g_wcDrive, -20,30);
	sleep(2000);
	WestCoaster_turnWithMPU(g_wcDrive, 20,30);
	//*/
//	WestCoaster_moveStraightWithMPU(g_wcDrive, -20*6*6/5*6/5.5,40);
//		WestCoaster_moveWithMPU(g_wcDrive, -5*6*6/5*6/5.5,70, 60, 6);
	//sleep(2000);
	//WestCoaster_moveStraightWithMPU(g_wcDrive, -160,50);
	/*sleep(2000);
	WestCoaster_moveStraightWithMPU(g_wcDrive, -20,50);
	sleep(2000);
	WestCoaster_moveStraightWithMPU(g_wcDrive, 60,50);
*/

	// WestCoaster_controlledEncoderObservedTurn(g_wcDrive,90,35);
	//sleep(1500);
	/*   WestCoaster_controlledEncoderObservedTurn(g_wcDrive,-90,75);
	sleep(1500);
	WestCoaster_controlledEncoderObservedTurn(g_wcDrive,180,75);
	sleep(1500);
	WestCoaster_controlledEncoderObservedTurn(g_wcDrive,-180,75);
	*/
	//	WestCoaster_controlledEncoderObservedTurn(g_wcDrive,60,35);
	//=======================================================================

	//back off the ramp, 56.9 inches from edge of field to front of bot
	//back of bot is 56.9+18=74.9 inches from edge of field
	// center of 60cm goal is 4.5*24=108 inches from edge
	//so need to move 108-74.9 to the center
	// then subtract the goal and robot faucet extents
	// and half-inch safety margin*/
	/*OFF_RAMP_DIST
	+108 - 74.9
	-FAUCET_EXTEND_BACK_CENTER
	-0.5;*/

	float distance_to_60cm =-72;
	//go down the ramp
	//sleep(1000);
	//  WestCoaster_controlledStraightMove(g_wcDrive, distance_to_60cm, 35);
//	sleep(1000);
	grabGoal();
	sleep(1000);
	/*sleep(1000);
	//drop the little one
	readyFaucet();
	sleep(1000);
	servo[hingeFaucet] = HINGE_FAUCET_FLIP;
	sleep(3000);
	WestCoaster_pidMPUTurn(g_wcDrive,30);
	sleep(1000);
	//deadReck
	sleep(1000);
	servo[spout] = SPOUT_OUT;
	//go grab another on
	//
	//fansOn(3000);

	*/
}
