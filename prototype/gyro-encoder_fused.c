#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     Gyro,           sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     FrontL,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     BackL,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     FrontR,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     BackR,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     motorJ,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     motorK,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define GYRO_PRECISION 2 //we do auto calibrate now,
//but will use encoders to turn on/off calibration
#include "hitechnic-gyro-task.c"
const int TURN_POWER=100;
const int easing_zone =60;//to be tuned
const int TOLERANCE=1;
const float kp = 1.0/easing_zone;
const float kd = 0.0;//not  needed
const float ki = 0.001;//to be tuned to eliminate offset
/**
* Turn left for given degrees, negative means turn right
*/
void turn(int degrees)
{
	hogCPU();
	int heading= (gHeading+0.5);
	float dedt = -gRot;
	releaseCPU();
	int target_heading = heading+degrees;
	//turn left if degrees to turn is positive
int full_power =degrees>0? -TURN_POWER:TURN_POWER;

	float pid_output=0;
	int err=degrees;
	float err_integral=0;
	long last_action_time;
	long prev_meas_time=nSysTime;
	while(true)
	{
		int power =0;
		//calculate power based on err.
		if(abs(err)>TOLERANCE||abs(dedt)>5.0)
		{
			pid_output =err*kp+err_integral*ki;
			if(abs(dedt)>2)//sensor noise when rotation below 2 degrees/sec
				pid_output += kd*dedt;
			last_action_time=nSysTime;
			if(pid_output<-1)
				pid_output=-1;
			if(pid_output>1)
				pid_output=1;
		}

		power=full_power*pid_output+0.5;
		writeDebugStreamLine("targ: %d, head: %d, power: %d, dedt: %f, int:%f", target_heading, heading,power,dedt,err_integral);
		motor[FrontR] = power;
		motor[FrontL] = power;
		motor[BackR] = power;
		motor[BackL] = power;
		if(nSysTime-last_action_time>100)
		{
			//robot has been stable for 100 ms
			//we are done turning
			break;
		}else
		{
			//keep measuring just to see if it will be stable
		}

		sleep(5);
		//measuring
		hogCPU();
		heading = (gHeading+0.5);
		dedt=-gRot;
		releaseCPU();
		err=target_heading-heading;
		//TODO: we need timestamp measurement in gyro task
		err_integral += err*(nSysTime-prev_meas_time)/1000.0;
		prev_meas_time=nSysTime;
	}
}


task main()
{
	startTask(gyro_loop);
	while(gyro_loop_state!=READING) sleep(5);
	sleep(1000);
	turn(180);
	/*	sleep(1000);
	turn(-90);//did it get to original?
	sleep(1000);
	turn(180);
	sleep(1000);
	turn(-180);
	sleep(1000);
	turn(135);
	sleep(1000);
	turn(-135);
	sleep(1000);

	turn(30);
	sleep(1000);
	turn(-30);
	sleep(1000);

	turn(15);
	sleep(1000);
	turn(-15);
	sleep(1000);*/
}
