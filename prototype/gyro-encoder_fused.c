/*#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     Gyro,           sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     BackL,         tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C1_2,     FrontL,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     BackR,         tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S2_C1_2,     FrontR,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     motorJ,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     motorK,        tmotorTetrix, openLoop)*/
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////////////////////////////////////////////////
// gyro_enocoder_fused is the file where we keep all miscellaneous methods
//    we need for our main programs(library)  //
//////////////////////////////////////////////////////////////////////////////////////////


#include "ultraSoundAutonomous.c" // sonar Sensor functionality
/**
* Robot characteristics. these are constant, only change when robot is re-designed
*/

// half-width of robot in inches measured from center-plane of left wheels to
// center plane of right side wheels
const int robotHalfWidth = 8.25;
// wheel radius in inches
const int wheelRad = 2;
// encoder counts per revolution of the motor output shaft
const int cpr = 1120;
// gear ratio of the drive train, turns of wheels
// for each revolution of motor output shaft
const float gear_ratio = 2.6;
// full power level for moving forward
const int FULL_POWER_FORWARD = 80;
// full power level for turning left
const int FULL_POWER_LEFT_TURN = 80;



int inchesToCounts(float inches)
{
	return abs((int)((cpr*inches)/(PI*wheelRad*2.0)/gear_ratio+0.5));
}
/**
* converts rotation degrees to encoder counts
*/
int degreesToCounts(int degrees)
{
	return abs((int)((degrees * robotHalfWidth *cpr)/(360.0*wheelRad)/gear_ratio +0.5));
}


/**
* Turn left for given degrees, negative means turn right
*/
void allMotorsPowerRot(int power){ //set power to the Motors during turning
	motor[FrontR] = power;
	motor[FrontL] = power;
	motor[BackR] = power;
	motor[BackL] = power;
	motor[MidR] = power;
	motor[MidL] = power;
}

void allMotorsPowerStraight(int power){ // set power for motors while moving straight
	motor[FrontR] = -power;
	motor[FrontL] = power;
	motor[BackR] = -power;
	motor[BackL] = power;
	motor[MidR] = -power;
	motor[MidL] = power;
}

int observedBrakingOffSetL=180;
int observedBrakingOffSetR=180;

//move straight with set power
void controlledStraightMove(float inches, int power){
	nMotorEncoder[FrontL] = 0;
	nMotorEncoder[FrontR] = 0;
	int countToTurn = inchesToCounts(inches);
	if(countToTurn==0) return;
	if(inches < 0){
		power = -power;
	}

	allMotorsPowerStraight(power);
	while(abs(nMotorEncoder[FrontL]) < countToTurn
		&& abs(nMotorEncoder[FrontR])< countToTurn){
		writeDebugStreamLine(" %d,%d,%d",
		nMotorEncoder[FrontL],nMotorEncoder[FrontR], nSysTime);
		sleep(5);
	}
	allMotorsPowerStraight(0);
	int	last_encoderL=nMotorEncoder[FrontL];
	int	last_encoderR=nMotorEncoder[FrontR];

	do{
		last_encoderL=nMotorEncoder[FrontL];
		last_encoderR=nMotorEncoder[FrontR];
		writeDebugStreamLine("counts:%d-off:%d/%d, encoderL: %d, encoderR: %d, power: %d, time: %d",
		countToTurn, observedBrakingOffSetL, observedBrakingOffSetR,
		last_encoderL, last_encoderR, 0,  nSysTime);
		sleep(20);
	}while(nMotorEncoder[FrontL]!=last_encoderL ||
		nMotorEncoder[FrontR]!=last_encoderR);

	writeDebugStreamLine("counts:%d-off:%d/%d, encoderL: %d, encoderR: %d, power: %d, time: %d",
	countToTurn, observedBrakingOffSetL, observedBrakingOffSetR,
	last_encoderL, last_encoderR, 0, nSysTime);

}

void straightMove(float inches){ //move straight with full power
	controlledStraightMove(inches, FULL_POWER_FORWARD);
}

void controlledEncoderObservedTurn(int target, int powerDesired){
	nMotorEncoder[FrontR] = 0;
	nMotorEncoder[FrontL] = 0;
	int countToTurn = degreesToCounts(target);
	int beginningEncoderR=0;
	int beginningEncoderL=0;
int power=target<0? -powerDesired:powerDesired;
	allMotorsPowerRot(power);

	while(abs(beginningEncoderR)< countToTurn-observedBrakingOffSetR &&
		abs(beginningEncoderL) < countToTurn-observedBrakingOffSetL)
	{
		sleep(20);
		beginningEncoderR = nMotorEncoder[FrontR];
		beginningEncoderL = nMotorEncoder[FrontL];
		writeDebugStreamLine("counts:%d-off:%d/%d, encoderL: %d, encoderR: %d, power: %d, time: %d",
		countToTurn, observedBrakingOffSetL,observedBrakingOffSetR,
		beginningEncoderL, beginningEncoderR, power, nSysTime);
	}

	allMotorsPowerRot(0);
	int last_encoderL=beginningEncoderL;
	int last_encoderR=beginningEncoderR;

	do{
		last_encoderL=nMotorEncoder[FrontL];
		last_encoderR=nMotorEncoder[FrontR];
		writeDebugStreamLine("counts:%d-off:%d/%d, encoderL: %d, encoderR: %d, power: %d, time: %d",
		countToTurn, observedBrakingOffSetL, observedBrakingOffSetR,
		last_encoderL, last_encoderR, 0,  nSysTime);
		sleep(20);
	}while(nMotorEncoder[FrontL]!=last_encoderL ||
		nMotorEncoder[FrontR]!=last_encoderR);

	//	observedBrakingOffSetL=abs(last_encoderL-beginningEncoderL);
	//	observedBrakingOffSetR=abs(last_encoderR-beginningEncoderR);
	//observedGyroOffSet=gHeading-target;
}

void encoderObservedTurn(int target){
	controlledEncoderObservedTurn(target, FULL_POWER_LEFT_TURN);
}

/////////////////////////////////////////
// these are for center goal moves
/////////////////////////////////////////
#if 0
int turnAndRecord(){
	int leastValue = 0;
	int sonarSensorF = 0;
	nMotorEncoder[FrontR] = 0;
	int encoderR = 0;
	unsigned long startT = nSysTime;
	allMotorsPowerRot(100);
	while(nSysTime < startT + 700 ){
		sonarSensorF = SensorValue[sonarSensor];
		if(sonarSensorF !=255 && sonarSensorF < leastValue){
			leastValue = sonarSensorF;
			encoderR = nMotorEncoder[FrontR];
		}
	}
	allMotorsPowerRot(0);
	allMotorsPowerRot(-100);
	while(nSysTime < startT + 700 ){
	}
	allMotorsPowerRot(0);
	return encoderR;
}
void scanAndOrient(){
	nMotorEncoder[FrontR] = 0;
	int encoderR = turnAndRecord();
	while( abs(nMotorEncoder[FrontR])< encoderR){
		allMotorsPowerRot(60);
	}

}

void fansOn(unsigned long time) //turn the fans on for time milliseconds
{
	unsigned long targetTime = nSysTime + time;
	while(nSysTime < targetTime)
	{
		motor[FanL] = -100;
		motor[FanR] = 100;
	}

	motor[FanL] = 0;
	motor[FanR] = 0;
}
bool lineUpGoal(){
	if(SensorValue[sonarSensor] < 10){
		fansOn(4000);
		return true;
		}else{
		scanAndOrient();
		controlledStraightMove(1.5, 10);
		return false;
	}
}
#endif
//////////////////////////////////////////////////////////
//  end of center goal moves
//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
// methods to use with gyro to control orientation
// These are currently at retired state
//////////////////////////////////////////////////////////
#if 0
#define GYRO_PRECISION 2 //we do auto calibrate now,
//but will use encoders to turn on/off calibration
#include "hitechnic-gyro-task.c" // gyro sensor functionality

// tolerance for gyro based turn control in degrees
const int TOLERANCE=1;
//minus offset 16 degrees
void gyroSimpleTurn(int degrees) //turn the robot number of degrees using the gyro
{
	hogCPU();
	int heading= (gHeading+0.5);
	releaseCPU();
	int target_heading = heading+degrees;
	//turn left if degrees to turn is positive
int full_power =degrees<0? -FULL_POWER_LEFT_TURN:FULL_POWER_LEFT_TURN;
	int power=full_power;
	int err=degrees;
	allMotorsPowerRot(power);
	while(abs(err)>TOLERANCE)
	{
		//measuring
		hogCPU();
		heading = (gHeading+0.5);
		releaseCPU();
		err=target_heading-heading;
		int encoderR = nMotorEncoder[FrontR];
		int encoderL = nMotorEncoder[FrontL];
		writeDebugStreamLine("targ: %d, head: %d, err: %d, encoderR: %d, encoderL: %d",
		target_heading, heading,err, encoderR, encoderL);

	}
	allMotorsPowerRot(0);
	long last_action_time=nSysTime;
	while(nSysTime-last_action_time<3000)
	{
		//measuring
		hogCPU();
		heading = (gHeading+0.5);
		releaseCPU();
		err=target_heading-heading;
		int encoderR = nMotorEncoder[FrontR];
		int encoderL = nMotorEncoder[FrontL];
		writeDebugStreamLine("targ: %d, head: %d, err: %d, encoderR: %d, encoderL: %d, time: %d",
		target_heading, heading,err, encoderR, encoderL, nSysTime);
		sleep(20);
	}
}

#endif

/*
task main()
{
startTask(gyro_loop);
while(gyro_loop_state!=READING) sleep(5);
sleep(1000);
//gyroTurn(180);
encoderTurn(180);
/*	sleep(1000);
turn(-90);//did it get to original?
sleep(1000);
turn(180);
sleep(1000);
turn(-180);
sleep(1000);
turn(135).,;....................cyy	sleep(1000);
turn(-15);
sleep(1000);*/
//}
